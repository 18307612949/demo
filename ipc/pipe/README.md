##pipe说明

###匿名管道
* anonymous_pipe01.c
* anonymous_pipe02.c

###FIFO 有名管道
包含3个文件，fifo\_write会打开data.txt，将其内容写入FIFO管道，而fifo\_read就会从FIFO管道中读出管道内容, 并写入一个新的文件datafromfifo.txt中

* fifo_read.c
* fifo_write.c
* data.txt

##关于管道和FIFO使用的一些注意事项

* 创建出一个FIFO后，它必须或者打开来读，或者打开来写。不能打开来既读又写，因为它是**半双工**的
* 对管道或FIFO的write总是往末尾添加数据，对它们的read总是从开头返回数据。如果对管道或FIFO执行lseek，会返回ESPIPE错误
* 创建并打开一个管道，只需要调用pipe；
  创建并打开一个FIFO则需在调用mkdifo后再调用open
* 管道在所有进程最终都关闭它之后自动消失。
  FIFO的名字则只有通过调用unlink才从文件系统中删除
* FIFO需要额外调用的好处：FIFO在文件系统中有一个名字，该名字允许某个进程创建一个FIFO，与它**无亲缘关系**的  另一个进程来打开这个FIFO，这对管道来说是不可能的（不考虑传递描述符的情况）
* 如果一个FIFO，当前尚没有进程打开它来写，那么此时打开该FIFO来读的进程将会阻塞
* 当对一个管道或FIFO的最终close发生时，该管道或FIFO中的任何残留数据都被丢弃

* **一个描述符有两种方式设置为非阻塞**
  1. 调用open的时候可指定O_NONBLOCK标志
  2. 如果一个描述符已打开，那么可以调用fcntl以启用O\_NONBLOCK标志。对于管道来说，必须使用这种技术，因为管道没有open调用，在pipe中也无法指定O\_NONBLOCK标志

* **FIFO的真正优势**表现在服务器可以是一个长期运行的进程（例如守护进程），而且与其客户可以无亲缘关系。
  作为服务器的守护进程以某个众所周知的路径名创建一个FIFO，并打开该FIFO来读。此后某个时刻启动的客户打开  该FIFO来写，并将其命令或给守护进程的其他任何东西通过该FIFO发送出去。使用FIFO很容易实现这种形式的单向  通信（client->server）。如果守护进程需要向客户发送回一些东西，那就需要点技巧（例如客户需要通知守护进  程要打开哪个FIFO可以给其发消息）
          
